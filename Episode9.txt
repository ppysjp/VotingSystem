We are going to use TDD to create the database.
Classic first step is to get a test that will get your foot throught the
door.
So we are going to create a simple test that saves to the database to 
get our foot through the door. We know from episode 7 that we are going
to be using an AppDbContext to do stuff with our database so the first
step is probably to create that. 
The point is at this point you have done the planning because you have
the domain knowledge to get stuff done.
We take the package references that we have got froom our SandboxEfCore
to instantiate the context that we want to use.

We then create a transactional scope which is done by doing a using 
statement. We want our database to have a set of counters so we know 
that we need to add a counter to the AppDbContext object so we do this
by adding the property. From our domain knowledge we know that the type
that the Counters property is going to be is going to be the following:

DbSet<counter>

So yeah. we create that.

We then create a new counter can check against.
In one using statement we save it to the database and in the other we 
retrieve it.
We then create a savedCounter instance which is the counter object that 
is retrieved from the database. We then assert that the old an new counters
are the same.

When I try and run the test it tells me that I need to override the 
OnConfiguring method. So we need to set it up to use the 
InMemoryDatabase.

However for this project is that we need to provide options through the 
constructor for the AppDbContext. This is a design choice. We want 
to provide a separate name for the database through the constructor
so that each database has a separate name. We want this because the tests
run in parallel and if they happen to use the same database by accident 
then we will get faulty test results.

You may need to revise a bit about how base key word works so here is 
a link here: 

https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/base#:~:text=base%20(C%23%20Reference)&text=The%20base%20keyword%20is%20used,instances%20of%20the%20derived%20class.

We then construct the options that we are going to pass into the context
by using a DbContextOptionsBuilder. So we have now passed the options 
into the AppDbContext object, so yeah we are now making some progress.


So we are now getting a primary key error so the next step is to fix 
this error. We need to ask ourselves whether the dataobject we are dealing
with actually needs a primary key specifically defined.

We use our domain knowledge in this case and override hthe OnModelCreating
function. So we have added the Counter table in the domain knowledge.

Finally we have the first test passing.



